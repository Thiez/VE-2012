sort 
	Zone = struct offline | idle | a | b | c | d;
	Error = struct actuator_error | sensor_error | communication_error | co_error;



map	instructions : List(List(Zone));
eqn	instructions = [[a,b],[a,b],[a,b]];

act
	% Robot actions
	send_request_clearance, recv_request_clearance, request_clearance : Nat # Nat # Zone;
	send_grant_clearance, recv_grant_clearance, grant_clearance : Nat;
	send_deny_clearance, recv_deny_clearance, deny_clearance : Nat;
	send_want_zone, recv_want_zone, want_zone : Nat # Zone;
	send_move_arm, recv_move_arm, move_arm : Nat # Zone;
	send_error, recv_error, error : Nat # Error;
	fault : Nat # Error;
	work;
	timeout;

	% Instructor actions
	send_issue_instructions, recv_issue_instructions, issue_instructions : Nat # List(Zone);
	send_confirmation, recv_confirmation, confirmation : Nat;

	% Platform actions
	send_bring_online, recv_bring_online, bring_online;
	send_bring_offline, recv_bring_offline, bring_offline;
	incoming_product, outgoing_product;
	send_all_clear, recv_all_clear, all_clear;
	send_all_clear_conf, recv_all_clear_conf, all_clear_conf;

proc
	Platform = 
		incoming_product . send_bring_online . recv_all_clear . send_bring_offline . outgoing_product . send_all_clear_conf . 
	 Platform;

	Instructor(inQueue:List(List(Zone))) =
		 sum n: Nat . (n<3) -> (
			recv_confirmation(n) . (
				(n == 0) -> Instructor([(tail (inQueue.n)), inQueue.1, inQueue.2]) +
				(n == 1) -> Instructor([inQueue.0, (tail (inQueue.n)), inQueue.2]) +
				(n == 2) -> Instructor([inQueue.0, inQueue.1, (tail (inQueue.n))])
			)
		) +
		(inQueue == [[],[],[]]) -> send_all_clear . recv_all_clear_conf .  Instruct(instructions);

	Instruct(inQueue:List(List(Zone))) =
		send_issue_instructions(0,inQueue.0) .
		send_issue_instructions(1,inQueue.1) .
		send_issue_instructions(2,inQueue.2) . Instructor(inQueue);

	Robot(n:Nat,z:Zone,zs:List(Zone),online:Bool) =
		online -> (
			(sum other_zs:List(Zone) .
				recv_issue_instructions(n,other_zs) . Robot(n,z,zs ++ other_zs,online)
			) +
			(sum other_z:Zone . (zs != [] && other_z == head(zs) && other_z != idle) -> send_want_zone(n,other_z) . % want_zone is internal: no comm errors.
				Permission_requests(n,other_z) .
				(send_move_arm(n,other_z) + Or_arm_error(n)) .
				work . (send_move_arm(n,idle) + Or_arm_error(n)). (send_confirmation(n) + Or_arm_error(n)) . Robot(n,idle,tail(zs),online)
			) +
			(zs != [] && head(zs) == idle) -> send_confirmation(n) . Robot(n,idle,tail(zs),online) + % We ack 'idle' commands without doing any work.
			recv_bring_offline . Robot(n,z,zs,false)
		) + 
		(! online) -> (
			recv_bring_online . Robot(n,z,zs,true)
		);
	
	Or_arm_error(n:Nat) =
		(n < 3) -> (Or_sensor_error(n) + Or_actuator_error(n));
	
	Or_sensor_error(n:Nat) =
		(n < 3) -> fault(n, sensor_error) . Error_state(n);
		
	Or_actuator_error(n:Nat) =
		(n < 3) -> fault(n, actuator_error) . Error_state(n);
	
	Or_communication_error(n:Nat) =	% if we detect a communication error, we go offline and hope for the best.
		(n < 3) -> fault(n, communication_error) -> send_move_arm(n,offline) . Error_state(n);
	
	Error_state(n:Nat) =
		(n < 3) -> delta;
	
	Permission_request(my_n:Nat,other_n:Nat,z:Zone) =
		(my_n < 3 && other_n < 3) ->
		send_request_clearance(my_n,other_n,z) . (
			recv_grant_clearance(my_n) +
			recv_deny_clearance(my_n) . Permission_request(my_n,other_n,z)
		);
	
	Permission_requests(n:Nat,z:Zone,perm1:Bool,perm2:Bool) =
		((!perm1) -> Permission_request(n,(n+1) mod 3, z) . Permission_requests(n,z,true,perm2) +
		((!perm2) -> Permission_request(n,(n+2) mod 3, z) . Permission_requests(n,z,perm1,true) +
		(perm1 && perm2) -> ;

	Permission_acknowledger(n:Nat,current_z:Zone,desired_z:Zone) =
		(sum some_z:Zone . recv_want_zone(n,some_z) . Permission_acknowledger(n,current_z,some_z))
	+	(sum some_z:Zone . sum some_n:Nat . (some_n < 3 && some_n != n) -> recv_request_clearance(some_n,n,some_z) .
	% always allow:
	%	zones we don't occupy,
	%	the zones 'idle' and 'offline'
	%	any robot that has a lower number than us
			( (some_z != current_z || some_z == offline || some_z == idle || (other_n < n && some_z != current_z)) ->
				send_grant_clearance(other_n) <> send_deny_clearance(other_n) ) .
			Permission_acknowledger(n,z))
	+	(recv_move_arm(n,desired_z) . Permission_acknowledger(n,desired_z,idle);

proc
	Robot_0 = Robot(0,idle,[],false) || Permission_acknowledger(0,idle);
	Robot_1 = Robot(1,idle,[],false) || Permission_acknowledger(1,idle);
	Robot_2 = Robot(2,idle,[],false) || Permission_acknowledger(2,idle);
	Robots = Robot_0 || Robot_1 || Robot_2;
	System = Platform || Robots || ErrorMaker;
	Test = System || Instruct(instructions);

init
	allow(	{	request_clearance, grant_clearance, deny_clearance,
				issue_instructions, confirmation, work,
				bring_online, bring_offline, incoming_product, outgoing_product, all_clear, all_clear_conf, error, want_zone, move_arm},
			comm(	{	send_request_clearance | recv_request_clearance -> request_clearance,
						send_grant_clearance | recv_grant_clearance -> grant_clearance,
						send_deny_clearance | recv_deny_clearance -> deny_clearance,
						send_issue_instructions | recv_issue_instructions -> issue_instructions,
						send_confirmation | recv_confirmation -> confirmation,
						send_bring_online | recv_bring_online | recv_bring_online | recv_bring_online -> bring_online,
						send_bring_offline | recv_bring_offline | recv_bring_offline | recv_bring_offline -> bring_offline,
						send_all_clear | recv_all_clear -> all_clear,
						send_all_clear_conf | recv_all_clear_conf -> all_clear_conf,
						send_want_zone | recv_want_zone -> want_zone,
						send_move_arm -> move_arm,
						send_error | recv_error -> error
					},
				Test
			)
	);
