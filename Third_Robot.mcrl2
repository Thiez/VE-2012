sort 
	Zone = struct offline | idle | a | b | c | d;
	Error = struct actuator_error | sensor_error | communications_error | co_error;

map	instructions : List(List(Zone));
eqn	instructions = [[a,b],[a,b],[a,b]];

act
	% Robot actions
	send_request_clearance, recv_request_clearance, error_request_clearance, request_clearance : Nat # Nat # Zone;
	send_grant_clearance, recv_grant_clearance, error_grant_clearance, grant_clearance : Nat;
	send_deny_clearance, recv_deny_clearance, error_deny_clearance, deny_clearance : Nat;
	send_want_zone, recv_want_zone, want_zone : Nat # Zone;
	send_go_idle, recv_go_idle, go_idle : Nat;
	send_move_arm, recv_move_arm, error_move_arm, move_arm : Nat # Zone;
	send_error, recv_error, error : Nat # Error;
	work;
	faulty;

	% Instructor actions
	send_issue_instructions, recv_issue_instructions, issue_instructions : Nat # List(Zone);
	send_confirmation, recv_confirmation, confirmation : Nat;

	% Platform actions
	send_bring_online, recv_bring_online, bring_online;
	send_bring_offline, recv_bring_offline, bring_offline;
	incoming_product, outgoing_product;
	send_all_clear, recv_all_clear, all_clear;
	send_all_clear_conf, recv_all_clear_conf, all_clear_conf;

proc
	Platform = 
		incoming_product . send_bring_online . recv_all_clear . send_bring_offline . outgoing_product . send_all_clear_conf . 
	 Platform;

	Instructor(inQueue:List(List(Zone))) =
		 sum n: Nat . (n<3) -> (
			recv_confirmation(n) . (
				(n == 0) -> Instructor([(tail (inQueue.n)), inQueue.1, inQueue.2]) +
				(n == 1) -> Instructor([inQueue.0, (tail (inQueue.n)), inQueue.2]) +
				(n == 2) -> Instructor([inQueue.0, inQueue.1, (tail (inQueue.n))])
			)
		) +
		(inQueue == [[],[],[]]) -> send_all_clear . recv_all_clear_conf .  Instruct(instructions);

	Instruct(inQueue:List(List(Zone))) =
		send_issue_instructions(0,inQueue.0) .
		send_issue_instructions(1,inQueue.1) .
		send_issue_instructions(2,inQueue.2) . Instructor(inQueue);

	Robot(n:Nat,z:Zone,zs:List(Zone),online:Bool) =
		online -> (
			(sum other_zs:List(Zone) .
				recv_issue_instructions(n,other_zs) . Robot(n,z,zs ++ other_zs,online)
			) +
			(sum other_z:Zone . (zs != [] && other_z == head(zs)) -> send_want_zone(n,other_z) .
				Permission_requests(n,other_z) .
				send_move_arm(n,other_z) .
				work . send_go_idle(n) . send_confirmation(n) . Robot(n,idle,tail(zs),online)
			) +
			recv_bring_offline . Robot(n,z,zs,false)
			%(z != idle) -> (
			%	work . send_go_idle(n) . send_confirmation(n) . Robot(n,idle,zs,online)
			%)
		) + 
		(! online) -> (
			recv_bring_online . Robot(n,z,zs,true)
		);

%	Permission_requests(n:Nat,z:Zone) =
%		(n < 3) -> Permission_request((n+1) mod 3, z) . Permission_request((n+2) mod 3, z);
%		
	Permission_request(my_n:Nat,other_n:Nat,z:Zone) =
		(my_n < 3 && other_n < 3) ->
		send_request_clearance(my_n,other_n,z) . (
			recv_grant_clearance(my_n) +
			recv_deny_clearance(my_n) . Permission_request(my_n,other_n,z)
		);
	
	Permission_requests(n:Nat,z:Zone) =
		% Permission_request((n+1) mod 3, z) . Permission_request((n+2) mod 3, z);
		(n != 1) -> (Permission_request(n,(n+1) mod 3, z) . Permission_request(n,(n+2) mod 3, z))
		<> (Permission_request(n,(n+2) mod 3, z) . Permission_request(n,(n+1) mod 3, z));
%	Permission_request(n:Nat,z:Zone) = 
%		send_request_clearance(n,z) . (
%			recv_grant_clearance(n) +
%			recv_deny_clearance(n) . Permission_request(n,z)
%		);

	Permission_acknowledger(n:Nat,z:Zone) =
		(sum other_z:Zone . recv_want_zone(n,other_z) . Permission_acknowledger(n,other_z))
	+	(sum other_z:Zone . sum other_n:Nat . (other_n < 3) -> recv_request_clearance(other_n,n,other_z) .
	% always allow:
	%	zones we don't occupy,
	%	the zones 'idle' and 'offline'
	%	any robot that has a lower number than us
			( (other_z != z || other_z == offline || other_z == idle || other_n < n) ->
				send_grant_clearance(other_n) <> send_deny_clearance(other_n) ) .
			Permission_acknowledger(n,z))
	+	recv_go_idle(n) . Permission_acknowledger(n,idle);
	
	% Actuator_error(n:Nat,err:Bool) =
	%	(! err) -> sum z:Zone . recv_move_arm(n,z) . Actuator_error(n,false)
	%	<> send_error(actuator_error) . Actuator_error(n,true); % currently no recovery
	
	ErrorMaker =
		CommunicationErrors . ErrorMaker;
	
	CommunicationErrors =
		sum z:Zone . sum n:Nat . sum m:Nat . (n < 3 && m < 3) -> (
			error_request_clearance(n,m,z) +
			error_grant_clearance(n) +
			error_deny_clearance(n)
		) +
		faulty . delta;	% If 'faulty' is an allowed action, random errors may occur.

proc
	Robot_0 = Robot(0,idle,[],false) || Permission_acknowledger(0,idle);
	Robot_1 = Robot(1,idle,[],false) || Permission_acknowledger(1,idle);
	Robot_2 = Robot(2,idle,[],false) || Permission_acknowledger(2,idle);
	Robots = Robot_0 || Robot_1 || Robot_2;
	System = Platform || Robots || ErrorMaker;
	Test = System || Instruct(instructions);

init
	allow(	{	request_clearance, grant_clearance, deny_clearance, go_idle,
				issue_instructions, confirmation, work,
				bring_online, bring_offline, incoming_product, outgoing_product, all_clear, all_clear_conf, error, want_zone, move_arm},
			comm(	{	send_request_clearance | recv_request_clearance | error_request_clearance -> request_clearance,
						send_grant_clearance | recv_grant_clearance | error_grant_clearance -> grant_clearance,
						send_deny_clearance | recv_deny_clearance | error_deny_clearance -> deny_clearance,
						send_issue_instructions | recv_issue_instructions -> issue_instructions,
						send_confirmation | recv_confirmation -> confirmation,
						send_bring_online | recv_bring_online | recv_bring_online | recv_bring_online -> bring_online,
						send_bring_offline | recv_bring_offline | recv_bring_offline | recv_bring_offline -> bring_offline,
						send_all_clear | recv_all_clear -> all_clear,
						send_all_clear_conf | recv_all_clear_conf -> all_clear_conf,
						send_want_zone | recv_want_zone -> want_zone,
						send_go_idle | recv_go_idle -> go_idle,
						send_move_arm | error_move_arm -> move_arm,
						send_error | recv_error -> error
					},
				Test
			)
	);
